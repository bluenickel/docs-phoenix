{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to Phoenix Docs", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-phoenix-docs", 
            "text": "", 
            "title": "Welcome to Phoenix Docs"
        }, 
        {
            "location": "/developer/modules/get-started/", 
            "text": "\ufeff# Getting started with modules", 
            "title": "Get Started"
        }, 
        {
            "location": "/developer/modules/client-modules/get-started/", 
            "text": "\ufeff# Get started with client modules\nModules are split into two types, client modules and server modules. This document describes how you can get started with a new client side module using the module-skeleton on top of the \nAurelia\n framework.\n\n\n1. Clone/Download the module skeleton\n\n\nYou will need to clone the module skeloton or download it from the git repository.\n\n\nGit clone\n\n\nUse the following command to clone the module skeleton repository into the desired directory.\n\n\ngit clone https://bluenickel.visualstudio.com/Phoenix-Platform/_git/Module-Skeleton [module name]\n\n\n\n\n[module name]\n is the name of the module which you wish to create and this will create a new directory of this name. The repository will be cloned into this directory.\n\n\nSince the repository you just cloned has a remote to the module-skeleton repository (i.e any commits would be pushed back to this repo which is undesirable), you will need to remove the origin with the following command.\n\n\ngit remote remove origin\n\n\n\n\nYou can then add a new origin to the location of your actual module repository on VSTS, Github or other Git service. You can use the following command to do so.\n\n\ngit remote add origin [url of remote git repository]\n\n\n\n\nNote\n: You will need an authorised Microsoft account to access the repository.\n\n\nNote\n: You will need a git client installed in order to perform the git commands above. See \nGit for windows\n.\n\n\nDownload\n\n\nYou can download the repository as a zip file by browsing to the following link. Extract the contents to the desired location.\n\n\nhttps://bluenickel.visualstudio.com/Phoenix-Platform/_git/Module-Skeleton\n\n\n\n\n2. Preparing the module\n\n\nIf you are using Visual Studio, rename \nModule-Skeleton.csproj\n and \nModule-Skeleton.sln\n to the desired name of your moduel.\n\n\nIf you are using Visual Studio Code or another similar editor such as Sublime or Atom, you may optionally delete the two files above.\n\n\nNote:\n If you are using Visual Studio, you will need to remove the reference to the Module-Skeleton project in the solution and add an existing project for the project file that you have renamed.\n\n\nRename the directory \nsrc/module-skeleton\n to the name name of your module.\n\n\nEdit the information in package.json to reflect your new module.\n\n\n\n\n3. Install Dependencies\n\n\nYou need to install NPM and JSPM dependencies as well as the TypeScript typings. The following commands describe how to do this. All the commands in this section should be executed in the same directory as your module directory, the one you just created.\n\n\nInstall NPM dependencies\n\n\nTo install all NPM dependencies, use the following command.\n\n\nnpm install\n\n\n\n\nNote:\n You need to install \nNode.js\n before you can use NPM (Node Package Manager).\n\n\nNote:\n When opening the project in Visual Studio 2015, this command will be executed automatically. Look to see whether the command has been completed in Output window before continuing with the other commands.\n\n\nSetup the Phoenix JSPM registry\n\n\nIf you haven't done so already you will need to configure a JSPM endpoint for Phoenix dependencies. Use the following command to start the process and follow the prompts using the information below.\n\n\njspm registry create phx jspm-npm\n\n\n\n\nnpm registry: https://www.myget.org/F/phoenix/npm\nNo authentication configured, configure credentials? [no]:y\nConfigure token-based authentication? [no]:n\nEnter your npm username (optional): ***\nEnter your npm password (optional): ***\nWould you like to test these credentials? [yes]:\nok   npm authentication is working successfully.\n\n\n\n\nNote:\n Your npm username and password are your credentials for your MyGet account which has access to this feed.\n\n\nInstall JSPM dependencies\n\n\nUse the following command to install all JSPM dependencies.\n\n\njspm install\n\n\n\n\nInstall TypeScript type definitions\n\n\nIf you haven't done so already, you will need to install the \ntypings application\n using NPM. Use the following command to do this.\n\n\nnpm install typings -g\n\n\n\n\nInstall all the type definitions using the following command.\n\n\ntypings install\n\n\n\n\n4. Build and Run\n\n\nYou should now be able to build and/or run(watch) the new module. You can use the following commands to build and watch the module.\n\n\nTo build the module use the following command.\n\n\ngulp build\n\n\n\n\nTo watch the module which, will rebuild any files that change, you can use the following command.\n\n\ngulp watch\n\n\n\n\nTo serve the module, which will allow you to browse to the module (usually at http://localhost:9000) use the following command.\n\n\ngulp serve\n\n\n\n\nYou can also use the 'Task Runner Explorer' in Visual Studio to run the tasks above. To open this window go to \nView-\nOther Windows-\nTask Runner Explorer\n.\n\n\nIf you see a message saying 'Failed to load. See output window...'. Try the following.\n\n\n\n\nFrom the menu, open \nTools-\nOptions\n\n\nThen look for \nProjects and Solutions-\nExternal Web Tools\n\n\nAdd a new entry to \nC:\\Program Files\\nodejs\n (for an x64 install of Node.js) and move it to the top.\n\n\n\n\n\n\nHosting the module\n\n\nThere are two options for hosting the module. You can use a local IIS server and configure the module project in Visual Studio, or, you can use the gulp serve task.\n\n\nWe will leave out how to use a local IIS server for now. Use the serve task above to host the site and then browse to http://localhost:9000.\n\n\nYou should see the default module tempalte and menu.", 
            "title": "Client Modules"
        }, 
        {
            "location": "/developer/modules/client-modules/get-started/#1-clonedownload-the-module-skeleton", 
            "text": "You will need to clone the module skeloton or download it from the git repository.", 
            "title": "1. Clone/Download the module skeleton"
        }, 
        {
            "location": "/developer/modules/client-modules/get-started/#git-clone", 
            "text": "Use the following command to clone the module skeleton repository into the desired directory.  git clone https://bluenickel.visualstudio.com/Phoenix-Platform/_git/Module-Skeleton [module name]  [module name]  is the name of the module which you wish to create and this will create a new directory of this name. The repository will be cloned into this directory.  Since the repository you just cloned has a remote to the module-skeleton repository (i.e any commits would be pushed back to this repo which is undesirable), you will need to remove the origin with the following command.  git remote remove origin  You can then add a new origin to the location of your actual module repository on VSTS, Github or other Git service. You can use the following command to do so.  git remote add origin [url of remote git repository]  Note : You will need an authorised Microsoft account to access the repository.  Note : You will need a git client installed in order to perform the git commands above. See  Git for windows .", 
            "title": "Git clone"
        }, 
        {
            "location": "/developer/modules/client-modules/get-started/#download", 
            "text": "You can download the repository as a zip file by browsing to the following link. Extract the contents to the desired location.  https://bluenickel.visualstudio.com/Phoenix-Platform/_git/Module-Skeleton", 
            "title": "Download"
        }, 
        {
            "location": "/developer/modules/client-modules/get-started/#2-preparing-the-module", 
            "text": "If you are using Visual Studio, rename  Module-Skeleton.csproj  and  Module-Skeleton.sln  to the desired name of your moduel.  If you are using Visual Studio Code or another similar editor such as Sublime or Atom, you may optionally delete the two files above.  Note:  If you are using Visual Studio, you will need to remove the reference to the Module-Skeleton project in the solution and add an existing project for the project file that you have renamed.  Rename the directory  src/module-skeleton  to the name name of your module.  Edit the information in package.json to reflect your new module.", 
            "title": "2. Preparing the module"
        }, 
        {
            "location": "/developer/modules/client-modules/get-started/#3-install-dependencies", 
            "text": "You need to install NPM and JSPM dependencies as well as the TypeScript typings. The following commands describe how to do this. All the commands in this section should be executed in the same directory as your module directory, the one you just created.", 
            "title": "3. Install Dependencies"
        }, 
        {
            "location": "/developer/modules/client-modules/get-started/#install-npm-dependencies", 
            "text": "To install all NPM dependencies, use the following command.  npm install  Note:  You need to install  Node.js  before you can use NPM (Node Package Manager).  Note:  When opening the project in Visual Studio 2015, this command will be executed automatically. Look to see whether the command has been completed in Output window before continuing with the other commands.", 
            "title": "Install NPM dependencies"
        }, 
        {
            "location": "/developer/modules/client-modules/get-started/#setup-the-phoenix-jspm-registry", 
            "text": "If you haven't done so already you will need to configure a JSPM endpoint for Phoenix dependencies. Use the following command to start the process and follow the prompts using the information below.  jspm registry create phx jspm-npm  npm registry: https://www.myget.org/F/phoenix/npm\nNo authentication configured, configure credentials? [no]:y\nConfigure token-based authentication? [no]:n\nEnter your npm username (optional): ***\nEnter your npm password (optional): ***\nWould you like to test these credentials? [yes]:\nok   npm authentication is working successfully.  Note:  Your npm username and password are your credentials for your MyGet account which has access to this feed.", 
            "title": "Setup the Phoenix JSPM registry"
        }, 
        {
            "location": "/developer/modules/client-modules/get-started/#install-jspm-dependencies", 
            "text": "Use the following command to install all JSPM dependencies.  jspm install", 
            "title": "Install JSPM dependencies"
        }, 
        {
            "location": "/developer/modules/client-modules/get-started/#install-typescript-type-definitions", 
            "text": "If you haven't done so already, you will need to install the  typings application  using NPM. Use the following command to do this.  npm install typings -g  Install all the type definitions using the following command.  typings install", 
            "title": "Install TypeScript type definitions"
        }, 
        {
            "location": "/developer/modules/client-modules/get-started/#4-build-and-run", 
            "text": "You should now be able to build and/or run(watch) the new module. You can use the following commands to build and watch the module.  To build the module use the following command.  gulp build  To watch the module which, will rebuild any files that change, you can use the following command.  gulp watch  To serve the module, which will allow you to browse to the module (usually at http://localhost:9000) use the following command.  gulp serve  You can also use the 'Task Runner Explorer' in Visual Studio to run the tasks above. To open this window go to  View- Other Windows- Task Runner Explorer .  If you see a message saying 'Failed to load. See output window...'. Try the following.   From the menu, open  Tools- Options  Then look for  Projects and Solutions- External Web Tools  Add a new entry to  C:\\Program Files\\nodejs  (for an x64 install of Node.js) and move it to the top.", 
            "title": "4. Build and Run"
        }, 
        {
            "location": "/developer/modules/client-modules/get-started/#hosting-the-module", 
            "text": "There are two options for hosting the module. You can use a local IIS server and configure the module project in Visual Studio, or, you can use the gulp serve task.  We will leave out how to use a local IIS server for now. Use the serve task above to host the site and then browse to http://localhost:9000.  You should see the default module tempalte and menu.", 
            "title": "Hosting the module"
        }, 
        {
            "location": "/developer/modules/service-modules/get-started/", 
            "text": "Get Started with Phoenix Service Modules\n\n\nThe Phoenix platform provides a web application base for building modular web services on the ASP.Net framework. It brings together the following elements.\n\n\n\n\nASP.Net Web API\n\n\nASP.Net Identity Framework\n\n\nDependency Injection using SimpleInjector\n\n\n\n\nSetting up a new web application\n\n\nTo begin a new web application, create a new, empty ASP.Net Web API project and install the Phoenix Web package.\n\n\nPM\n Install-Package Phoenix.Web\n\n\n\n\nThen add a new \nStartup.cs\n file with the following contents.\n\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Web;\nusing Microsoft.Owin;\nusing Owin;\nusing Phoenix.Web;\n\n\n[assembly: OwinStartup(typeof(MyWebApplication.Startup))]\n\n\nnamespace MyWebApplication\n{\n    public class Startup\n    {\n\n\n    public void Configuration(IAppBuilder app)\n    {\n        app.UsePhoenix();\n    }\n}\n\n\n\n}\n\n\n\nThat's all you have to do to get a modular web application running using the Phoenix platform.\n\n## Add a new module\nTo create a new service module, add a new empty class library project to your solution.\n\nIt is recommended that you add a folder for `Controllers` and `Permissions` but you may put these classes where ever you like.\n\n![Module Structure](resources/get-started-solution.png)\n\nAdd a class to define information about your module. For this example, we've added  the `MyModule` class which implements the `IPhoenixModule` interface. Implement the required members as follows.\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace MyModule\n{\n    public class MyModule : IPhoenixModule\n    {\n        public string Name\n        {\n            get\n            {\n                return \nMy Module\n;\n            }\n        }\n\n        public string Description\n        {\n            get\n            {\n                return \nMy Module does some really great stuff.\n;\n            }\n        }\n\n        /// \nsummary\n\n        /// Returns all permission groups for the module\n        /// \n/summary\n\n        public IEnumerable\nIPermissionGroup\n PermissionGroups\n        {\n            get\n            {\n                return new List\nIPermissionGroup\n()\n                {\n                    new Permissions.MyFeaturePermissions()\n                };\n            }\n        }\n\n        public MyModule(/*Use dependency injection to inject any dependencies here*/)\n        {\n            //Module initialisation code goes here.\n        }\n\n        public void Configure(params object[] args)\n        {\n            //You can configure the module here.\n            //This is called when the web application starts.\n        }\n    }\n}\n\n\n\n\n\nYou may have noticed the \nPermissionGroups\n member. We'll get to that in the next section. For now, you may simply add Web API controllers to the controllers folder and compile. Copy the compiled dll to the \nbin/Modules\n under the MyWebApplication project. The dll is loaded and everything is ready for you to start using the controllers in this module.\n\n\nConfiguring module permissions\n\n\nYou can configure module permissions for use with the \nPhoenix.Security\n package.\n\n\nInstall the \nPhoenix.Security\n package using the following command.\n\n\nPM\n Install-Package Phoenix.Security\n\n\n\n\nService modules, expose a list of \nPermissionGroups\n. A \nPermissionGroup\n is intended to define a set of permissions for a specific feature of your module. For example, if your module deals with products and you want to secure these you might define a permission group for products with the following permissions.\n\n\n\n\nCan View Product\n\n\nCan Create Product\n\n\nCan Edit Product\n\n\nCan Delete Product\n\n\n\n\nThis will allow you to control all CRUD related aspects of a product where only certain users can delete a product.\n\n\nA permission group can be define as follows.\n\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\n\nnamespace MyModule.Permissions\n{\n    public class MyFeaturePermissions\n    {\n        public string Description\n        {\n            get\n            {\n                return \"Controls access to process my feautre.\";\n            }\n        }\n\n\n    public string Name\n    {\n        get\n        {\n            return \"My Feature\";\n        }\n    }\n\n    public IEnumerable\nIPermission\n Permissions\n    {\n        get\n        {\n            return new List\nIPermission\n\n            {\n                new CanViewMyFeature(),\n                new CanCreateMyFeature(),\n                new CanDeleteMyFeature(),\n                new CanEditMyFeature()\n            };\n        }\n    }\n\n    public class CanViewMyFeature : PermissionBase, IPermission\n    {\n        public string Name { get { return \"View\"; } }\n        public string Description { get { return \"Provides access to view My Feature\"; } }\n    }\n\n    public class CanCreateMyFeature : PermissionBase, IPermission\n    {\n        public string Name { get { return \"Create\"; } }\n        public string Description { get { return \"Provides access to create new My Feature\"; } }\n    }\n\n    public class CanDeleteMyFeature : PermissionBase, IPermission\n    {\n        public string Name { get { return \"Delete\"; } }\n        public string Description { get { return \"Provides access to delete My Feature\"; } }\n    }\n\n    public class CanEditMyFeature : PermissionBase, IPermission\n    {\n        public string Name { get { return \"Edit\"; } }\n        public string Description { get { return \"Provides access to change My Feature\"; } }\n    }\n}\n\n\n\n}\n\n\n\nTo use permissions in a controller or anywhere throughout your code, you can use the `IPhoenixAccess` component can be acquired using dependency injection. The following code demonstrates this.\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing Phoenix.Access;\nusing static MyModule.Permissions.MyFeaturePermissions;\n\nnamespace MyModule.Controllers\n{\n    public class MyFeatureController\n    {\n        IPhoenixAccess access;\n\n        public MyFeatureController(IPhoenixAccess access /*Injected via DI*/)\n        {\n            this.access = access;\n        }\n\n        /// \nsummary\n\n        /// List all existing items of my feature\n        /// \n/summary\n\n        /// \nreturns\nMy features items\n/returns\n\n        [HttpGet]\n        [Route(\n)]\n        public IEnumerable\nstring\n ListItems()\n        {\n            access.CheckAccess\nCanViewMyFeature\n(RequestContext.Principal);\n\n            return new[] { \nItem 1\n, \nItem 2\n };\n        }\n    }\n}\n\n\n\n\n\nIf the current user (Principal) does not have access for this permission an exception will be thrown and the code will not continue to execute.\n\n\nAdding an existing module\n\n\nYou can use NuGet to install a module from a NuGet feed.\n\n\nComming Soon!", 
            "title": "Service Modules"
        }, 
        {
            "location": "/developer/modules/service-modules/get-started/#get-started-with-phoenix-service-modules", 
            "text": "The Phoenix platform provides a web application base for building modular web services on the ASP.Net framework. It brings together the following elements.   ASP.Net Web API  ASP.Net Identity Framework  Dependency Injection using SimpleInjector", 
            "title": "Get Started with Phoenix Service Modules"
        }, 
        {
            "location": "/developer/modules/service-modules/get-started/#setting-up-a-new-web-application", 
            "text": "To begin a new web application, create a new, empty ASP.Net Web API project and install the Phoenix Web package.  PM  Install-Package Phoenix.Web  Then add a new  Startup.cs  file with the following contents.  ```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Web;\nusing Microsoft.Owin;\nusing Owin;\nusing Phoenix.Web;  [assembly: OwinStartup(typeof(MyWebApplication.Startup))]  namespace MyWebApplication\n{\n    public class Startup\n    {      public void Configuration(IAppBuilder app)\n    {\n        app.UsePhoenix();\n    }\n}  }  \nThat's all you have to do to get a modular web application running using the Phoenix platform.\n\n## Add a new module\nTo create a new service module, add a new empty class library project to your solution.\n\nIt is recommended that you add a folder for `Controllers` and `Permissions` but you may put these classes where ever you like.\n\n![Module Structure](resources/get-started-solution.png)\n\nAdd a class to define information about your module. For this example, we've added  the `MyModule` class which implements the `IPhoenixModule` interface. Implement the required members as follows.\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace MyModule\n{\n    public class MyModule : IPhoenixModule\n    {\n        public string Name\n        {\n            get\n            {\n                return  My Module ;\n            }\n        }\n\n        public string Description\n        {\n            get\n            {\n                return  My Module does some really great stuff. ;\n            }\n        }\n\n        ///  summary \n        /// Returns all permission groups for the module\n        ///  /summary \n        public IEnumerable IPermissionGroup  PermissionGroups\n        {\n            get\n            {\n                return new List IPermissionGroup ()\n                {\n                    new Permissions.MyFeaturePermissions()\n                };\n            }\n        }\n\n        public MyModule(/*Use dependency injection to inject any dependencies here*/)\n        {\n            //Module initialisation code goes here.\n        }\n\n        public void Configure(params object[] args)\n        {\n            //You can configure the module here.\n            //This is called when the web application starts.\n        }\n    }\n}  You may have noticed the  PermissionGroups  member. We'll get to that in the next section. For now, you may simply add Web API controllers to the controllers folder and compile. Copy the compiled dll to the  bin/Modules  under the MyWebApplication project. The dll is loaded and everything is ready for you to start using the controllers in this module.", 
            "title": "Setting up a new web application"
        }, 
        {
            "location": "/developer/modules/service-modules/get-started/#configuring-module-permissions", 
            "text": "You can configure module permissions for use with the  Phoenix.Security  package.  Install the  Phoenix.Security  package using the following command.  PM  Install-Package Phoenix.Security  Service modules, expose a list of  PermissionGroups . A  PermissionGroup  is intended to define a set of permissions for a specific feature of your module. For example, if your module deals with products and you want to secure these you might define a permission group for products with the following permissions.   Can View Product  Can Create Product  Can Edit Product  Can Delete Product   This will allow you to control all CRUD related aspects of a product where only certain users can delete a product.  A permission group can be define as follows.  ```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;  namespace MyModule.Permissions\n{\n    public class MyFeaturePermissions\n    {\n        public string Description\n        {\n            get\n            {\n                return \"Controls access to process my feautre.\";\n            }\n        }      public string Name\n    {\n        get\n        {\n            return \"My Feature\";\n        }\n    }\n\n    public IEnumerable IPermission  Permissions\n    {\n        get\n        {\n            return new List IPermission \n            {\n                new CanViewMyFeature(),\n                new CanCreateMyFeature(),\n                new CanDeleteMyFeature(),\n                new CanEditMyFeature()\n            };\n        }\n    }\n\n    public class CanViewMyFeature : PermissionBase, IPermission\n    {\n        public string Name { get { return \"View\"; } }\n        public string Description { get { return \"Provides access to view My Feature\"; } }\n    }\n\n    public class CanCreateMyFeature : PermissionBase, IPermission\n    {\n        public string Name { get { return \"Create\"; } }\n        public string Description { get { return \"Provides access to create new My Feature\"; } }\n    }\n\n    public class CanDeleteMyFeature : PermissionBase, IPermission\n    {\n        public string Name { get { return \"Delete\"; } }\n        public string Description { get { return \"Provides access to delete My Feature\"; } }\n    }\n\n    public class CanEditMyFeature : PermissionBase, IPermission\n    {\n        public string Name { get { return \"Edit\"; } }\n        public string Description { get { return \"Provides access to change My Feature\"; } }\n    }\n}  }  \nTo use permissions in a controller or anywhere throughout your code, you can use the `IPhoenixAccess` component can be acquired using dependency injection. The following code demonstrates this.\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Web.Http;\nusing Phoenix.Access;\nusing static MyModule.Permissions.MyFeaturePermissions;\n\nnamespace MyModule.Controllers\n{\n    public class MyFeatureController\n    {\n        IPhoenixAccess access;\n\n        public MyFeatureController(IPhoenixAccess access /*Injected via DI*/)\n        {\n            this.access = access;\n        }\n\n        ///  summary \n        /// List all existing items of my feature\n        ///  /summary \n        ///  returns My features items /returns \n        [HttpGet]\n        [Route( )]\n        public IEnumerable string  ListItems()\n        {\n            access.CheckAccess CanViewMyFeature (RequestContext.Principal);\n\n            return new[] {  Item 1 ,  Item 2  };\n        }\n    }\n}  If the current user (Principal) does not have access for this permission an exception will be thrown and the code will not continue to execute.", 
            "title": "Configuring module permissions"
        }, 
        {
            "location": "/developer/modules/service-modules/get-started/#adding-an-existing-module", 
            "text": "You can use NuGet to install a module from a NuGet feed.  Comming Soon!", 
            "title": "Adding an existing module"
        }, 
        {
            "location": "/developer/tools/get-started/", 
            "text": "Get Started with Tools\n\n\nThis document explains what tools are and shows how to quickly get started developing tools for Phoenix.\n\n\nOverview\n\n\nA tool is a component in Phoenix which can be used to perform some action within an execution workflow. An execution workflow is a collection of tools structured and designed in such a way to accomplish some task.\n\n\nAn example of an execution workflow may be generating and sending out a report by email. This worklflow might consist of the following tools.\n\n\n\n\nA tool to schedule when the report must be sent out.\n\n\nA report generation tool which generates the report and produces HTML or PDF.\n\n\nAn email tool which sends out an email containing the HTML or attached PDF to a list of recipients.\n\n\n\n\nAnother common example of an execution workflow is to extract, transform and write data from one location to another. This could be a workflow that extracts data from an Excel or CSV file and writes it into an MS SQL database. This workflow would consist of the following tools.\n\n\n\n\nAn Excel or CSV file reader tool to read the contents of the Excel or CSV file.\n\n\nA Script tool which converts the extracted data into a format compatible for the database.\n\n\nA Relational Database tool which writes data to a relational database such as MS SQL, My SQL, Oracle or any relational database supported by Entity Framework.\n\n\n\n\nTool Components\n\n\nTools consist of several components, both on the back-end and front-end. On the back-end tools consist of the following.\n\n\n\n\nTool - the root of the tool which is enumerated and describes all the child components.\n\n\nToolConfig - the tools configuration. This describes things like execution node and execution interval as well as other specific properties required for the tools execution.\n\n\nToolActor - the tool actor performs all the actions or logic for the tool and uses the ToolConfig to create connectors (more about connectors later) as well as connect to servers or data sources.\n\n\nToolService - the tool service provides optional services required to configure a tool of this type. For example, a Relational Database tool may provide a tool service which enumerates all databases on a given server. This allows the user to be able to enter in a IP address, machine name or Url on the tools' configuration form and then seeing a list of databases which they can then select one of.\n\n\n\n\nOn the front-end, the components are views and view-models which describe the visual aspects of the tool and provide a user friendly way for the tool to be configured.\n\n\n\n\nVisual - the view/view-model representing how the tool is displayed on the workspace (workflow diagram).\n\n\nConfig - the view/view-model for the configuration dialog that is presented to the user when configuring the settings for the tool.\n\n\n\n\nConnectors\n\n\nConnectors, as the name suggests, connects one tool to another tool. Connectors can be of various types and can be extended to suit most needs but typically, the data connector will be of most use. Connectors are provided by a tool and need to be updated when a tools' configuration changes. Every tool comes with a standard Execution Connector. This connector allows the flow of execution to be controlled from one tool to another. Generally there is nothing you need to do with this connector but you can add other Execution Actors to perform other actions which don't cause execution to be passed to any connected actors.\n\n\nWriting a basic tool\n\n\nThis section will walk you through creating a simple expression evaluating tool, based on the \nNCalc\n library.\n\n\n1. Setup Project\n\n\nCreate a new class library project. The name of this project can be the name of your tool. For example, \"Expression\".\n\n\nInstall the Phoenix.Execution package from NuGet.\n\n\nPM\n Install-Package Phoenix.Execution -Version 0.0.1-beta\n\n\n2. Install NCalc\n\n\nAt this point you should install any necessary dependencies for the tool. In this case we need NCalc so install it from NuGet.\n\n\nPM\n Install-Package NCalc\n\n\n3. Add the tool class\n\n\nThe tool class is a class that defines a tool. It does nothing more than to provide info about the tool. Add a class called ExpressTool to the project and derive it from \nPhoenix.Exceution.Tool\n. Then implement the abstract members.\n\n\n```c#\npublic class ExpressionTool : Tool\n{\n    public override string Category\n    {\n        get\n        {\n            return \"General\";\n        }\n    }\n\n\npublic override string Description\n{\n    get\n    {\n        return \"Evaluates an expression\";\n    }\n}\n\npublic override string Icon\n{\n    get\n    {\n        return \"\";\n    }\n}\n\npublic override string Key\n{\n    get\n    {\n        return \"general/expression\";\n    }\n}\n\npublic override string Name\n{\n    get\n    {\n        return \"Expression\";\n    }\n}\n\npublic override Type ServiceActorType\n{\n    get\n    {\n        return null;\n    }\n}\n\npublic override IEnumerable\nstring\n Tags\n{\n    get\n    {\n        return new[] {\n            \"general\",\n            \"math\",\n            \"expression\",\n            \"script\"\n        };\n    }\n}\n\npublic override Type ToolActorType\n{\n    get\n    {\n        return typeof(ExpressionActor);\n    }\n}\n\npublic override Type ToolConfigType\n{\n    get\n    {\n        return typeof(ExpressionConfig);\n    }\n}\n\npublic override string Version\n{\n    get\n    {\n        return \"0.0.1\";\n    }\n}\n\n\n\n}\n\n\n\n### 4. Add the tool config class\nThe tool config class allows us to setup a model for the configuration. This is where any properties required to execute the tool must go. Add a class called ExpressionConfig and derive it from `Phoenix.Execution.ToolConfig`. We will add a property called Expression to this class.\n\n```c#\npublic class ExpressionConfig : ToolConfig\n{\n    /// \nsummary\n\n    /// The epxression string\n    /// \n/summary\n\n    public string Expression { get; set; }\n\n    /// \nsummary\n\n    /// Parameters used for input connectors\n    /// \n/summary\n\n    public List\nstring\n Parameters { get; set; }\n\n    public ExpressionConfig()\n    {\n        Parameters = new List\nstring\n();\n    }\n}\n\n\n\n\n5. Add the tool actor class\n\n\nThere are two primary method to implement in the tool actor class these are,\n\n\n\n\nUpdate - called when the tool configuration is updated. This is where connectors are added and anything other initialization occurs.\n\n\nExecute - called when the tool is executed. This is where the execution logic is performed and results are sent on wards.\n\n\n\n\nThe implementation for the tool actor is as follows.\n\n\n```c#\npublic class ExpressionActor : ExecutionActor\n{\n    private NCalc.Expression expression;\n\n\npublic ExpressionActor(PersistenceConfig persistenceConfig) : base(persistenceConfig)\n{\n}\n\npublic ExpressionConfig ExpressionConfig\n{\n    get\n    {\n        return this.Config as ExpressionConfig;\n    }\n}\n\nprotected override Tool Tool\n{\n    get\n    {\n        return new ExpressionTool();\n    }\n}\n\nprotected override void Update()\n{\n    //Create an instance of the NCalc expression.\n    expression = new NCalc.Expression(ExpressionConfig.Expression);\n\n    //The expression will parse any parameters bases on the NCalc specification.\n    //These are added as connectors\n    foreach (var parameter in expression.Parameters.Keys)\n    {\n        AddConnector(new DataConnector\nobject\n(parameter));\n    }\n\n    //Add a connector for the result\n    AddConnector(new DataConnector\nobject\n(\"Result\"));\n}\n\nprotected override void Execute()\n{\n    //Set each NCalc expression parameter using the current value.\n    //Use GetCurrentValue to retrieve the value at the time of execution\n    foreach (var parameter in expression.Parameters.Keys)\n    {\n        expression.Parameters[parameter] = GetCurrentValue(parameter);\n    }\n\n    //Evaluate the expression\n    var result = expression.Evaluate();\n\n    //Get the result connector and send the value to any connected tools.\n    var resultConnector = GetConnector(\"Result\") as DataConnector;\n    resultConnector.Send(result);\n}\n\n\n\n}\n\n\n\n### 6. Add the tool service class\nFor this tool we don't need a service so it is left out. Here is an example of what a tool service might look like.\n\n```c#\npublic ExpressionService : ToolService\n{\n}\n\n\n\n\nFinishing up\n\n\nTo deploy the tool it will need to be copied into the \nModules\n folder of Node.Phoenix.", 
            "title": "Tools"
        }, 
        {
            "location": "/developer/tools/get-started/#get-started-with-tools", 
            "text": "This document explains what tools are and shows how to quickly get started developing tools for Phoenix.", 
            "title": "Get Started with Tools"
        }, 
        {
            "location": "/developer/tools/get-started/#overview", 
            "text": "A tool is a component in Phoenix which can be used to perform some action within an execution workflow. An execution workflow is a collection of tools structured and designed in such a way to accomplish some task.  An example of an execution workflow may be generating and sending out a report by email. This worklflow might consist of the following tools.   A tool to schedule when the report must be sent out.  A report generation tool which generates the report and produces HTML or PDF.  An email tool which sends out an email containing the HTML or attached PDF to a list of recipients.   Another common example of an execution workflow is to extract, transform and write data from one location to another. This could be a workflow that extracts data from an Excel or CSV file and writes it into an MS SQL database. This workflow would consist of the following tools.   An Excel or CSV file reader tool to read the contents of the Excel or CSV file.  A Script tool which converts the extracted data into a format compatible for the database.  A Relational Database tool which writes data to a relational database such as MS SQL, My SQL, Oracle or any relational database supported by Entity Framework.", 
            "title": "Overview"
        }, 
        {
            "location": "/developer/tools/get-started/#tool-components", 
            "text": "Tools consist of several components, both on the back-end and front-end. On the back-end tools consist of the following.   Tool - the root of the tool which is enumerated and describes all the child components.  ToolConfig - the tools configuration. This describes things like execution node and execution interval as well as other specific properties required for the tools execution.  ToolActor - the tool actor performs all the actions or logic for the tool and uses the ToolConfig to create connectors (more about connectors later) as well as connect to servers or data sources.  ToolService - the tool service provides optional services required to configure a tool of this type. For example, a Relational Database tool may provide a tool service which enumerates all databases on a given server. This allows the user to be able to enter in a IP address, machine name or Url on the tools' configuration form and then seeing a list of databases which they can then select one of.   On the front-end, the components are views and view-models which describe the visual aspects of the tool and provide a user friendly way for the tool to be configured.   Visual - the view/view-model representing how the tool is displayed on the workspace (workflow diagram).  Config - the view/view-model for the configuration dialog that is presented to the user when configuring the settings for the tool.", 
            "title": "Tool Components"
        }, 
        {
            "location": "/developer/tools/get-started/#connectors", 
            "text": "Connectors, as the name suggests, connects one tool to another tool. Connectors can be of various types and can be extended to suit most needs but typically, the data connector will be of most use. Connectors are provided by a tool and need to be updated when a tools' configuration changes. Every tool comes with a standard Execution Connector. This connector allows the flow of execution to be controlled from one tool to another. Generally there is nothing you need to do with this connector but you can add other Execution Actors to perform other actions which don't cause execution to be passed to any connected actors.", 
            "title": "Connectors"
        }, 
        {
            "location": "/developer/tools/get-started/#writing-a-basic-tool", 
            "text": "This section will walk you through creating a simple expression evaluating tool, based on the  NCalc  library.", 
            "title": "Writing a basic tool"
        }, 
        {
            "location": "/developer/tools/get-started/#1-setup-project", 
            "text": "Create a new class library project. The name of this project can be the name of your tool. For example, \"Expression\".  Install the Phoenix.Execution package from NuGet.  PM  Install-Package Phoenix.Execution -Version 0.0.1-beta", 
            "title": "1. Setup Project"
        }, 
        {
            "location": "/developer/tools/get-started/#2-install-ncalc", 
            "text": "At this point you should install any necessary dependencies for the tool. In this case we need NCalc so install it from NuGet.  PM  Install-Package NCalc", 
            "title": "2. Install NCalc"
        }, 
        {
            "location": "/developer/tools/get-started/#3-add-the-tool-class", 
            "text": "The tool class is a class that defines a tool. It does nothing more than to provide info about the tool. Add a class called ExpressTool to the project and derive it from  Phoenix.Exceution.Tool . Then implement the abstract members.  ```c#\npublic class ExpressionTool : Tool\n{\n    public override string Category\n    {\n        get\n        {\n            return \"General\";\n        }\n    }  public override string Description\n{\n    get\n    {\n        return \"Evaluates an expression\";\n    }\n}\n\npublic override string Icon\n{\n    get\n    {\n        return \"\";\n    }\n}\n\npublic override string Key\n{\n    get\n    {\n        return \"general/expression\";\n    }\n}\n\npublic override string Name\n{\n    get\n    {\n        return \"Expression\";\n    }\n}\n\npublic override Type ServiceActorType\n{\n    get\n    {\n        return null;\n    }\n}\n\npublic override IEnumerable string  Tags\n{\n    get\n    {\n        return new[] {\n            \"general\",\n            \"math\",\n            \"expression\",\n            \"script\"\n        };\n    }\n}\n\npublic override Type ToolActorType\n{\n    get\n    {\n        return typeof(ExpressionActor);\n    }\n}\n\npublic override Type ToolConfigType\n{\n    get\n    {\n        return typeof(ExpressionConfig);\n    }\n}\n\npublic override string Version\n{\n    get\n    {\n        return \"0.0.1\";\n    }\n}  }  \n### 4. Add the tool config class\nThe tool config class allows us to setup a model for the configuration. This is where any properties required to execute the tool must go. Add a class called ExpressionConfig and derive it from `Phoenix.Execution.ToolConfig`. We will add a property called Expression to this class.\n\n```c#\npublic class ExpressionConfig : ToolConfig\n{\n    ///  summary \n    /// The epxression string\n    ///  /summary \n    public string Expression { get; set; }\n\n    ///  summary \n    /// Parameters used for input connectors\n    ///  /summary \n    public List string  Parameters { get; set; }\n\n    public ExpressionConfig()\n    {\n        Parameters = new List string ();\n    }\n}", 
            "title": "3. Add the tool class"
        }, 
        {
            "location": "/developer/tools/get-started/#5-add-the-tool-actor-class", 
            "text": "There are two primary method to implement in the tool actor class these are,   Update - called when the tool configuration is updated. This is where connectors are added and anything other initialization occurs.  Execute - called when the tool is executed. This is where the execution logic is performed and results are sent on wards.   The implementation for the tool actor is as follows.  ```c#\npublic class ExpressionActor : ExecutionActor\n{\n    private NCalc.Expression expression;  public ExpressionActor(PersistenceConfig persistenceConfig) : base(persistenceConfig)\n{\n}\n\npublic ExpressionConfig ExpressionConfig\n{\n    get\n    {\n        return this.Config as ExpressionConfig;\n    }\n}\n\nprotected override Tool Tool\n{\n    get\n    {\n        return new ExpressionTool();\n    }\n}\n\nprotected override void Update()\n{\n    //Create an instance of the NCalc expression.\n    expression = new NCalc.Expression(ExpressionConfig.Expression);\n\n    //The expression will parse any parameters bases on the NCalc specification.\n    //These are added as connectors\n    foreach (var parameter in expression.Parameters.Keys)\n    {\n        AddConnector(new DataConnector object (parameter));\n    }\n\n    //Add a connector for the result\n    AddConnector(new DataConnector object (\"Result\"));\n}\n\nprotected override void Execute()\n{\n    //Set each NCalc expression parameter using the current value.\n    //Use GetCurrentValue to retrieve the value at the time of execution\n    foreach (var parameter in expression.Parameters.Keys)\n    {\n        expression.Parameters[parameter] = GetCurrentValue(parameter);\n    }\n\n    //Evaluate the expression\n    var result = expression.Evaluate();\n\n    //Get the result connector and send the value to any connected tools.\n    var resultConnector = GetConnector(\"Result\") as DataConnector;\n    resultConnector.Send(result);\n}  }  \n### 6. Add the tool service class\nFor this tool we don't need a service so it is left out. Here is an example of what a tool service might look like.\n\n```c#\npublic ExpressionService : ToolService\n{\n}", 
            "title": "5. Add the tool actor class"
        }, 
        {
            "location": "/developer/tools/get-started/#finishing-up", 
            "text": "To deploy the tool it will need to be copied into the  Modules  folder of Node.Phoenix.", 
            "title": "Finishing up"
        }
    ]
}